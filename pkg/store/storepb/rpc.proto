// Copyright (c) The Thanos Authors.
// Licensed under the Apache License 2.0.

syntax = "proto3";
package thanos;

import "types.proto";
import "gogoproto/gogo.proto";
import "github.com/prometheus/prometheus/prompb/types.proto";

option go_package = "storepb";

option (gogoproto.sizer_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;

// Do not generate XXX fields to reduce memory footprint and opening a door
// for zero-copy casts to/from prometheus data types.
option (gogoproto.goproto_unkeyed_all) = false;
option (gogoproto.goproto_unrecognized_all) = false;
option (gogoproto.goproto_sizecache_all) = false;

/// Store reprents API against instance that stores XOR encoded values with label set metadata (e.g Prometheus metrics).
service Store {
  /// Info returns meta information about a store e.g labels that makes that store unique as well as time range that is
  /// available.
  rpc Info(InfoRequest) returns (InfoResponse);

  /// Series streams each Series (Labels and chunk/downsampling chunk) for given label matchers and time range.
  ///
  /// Series should strictly stream full series after series, optionally split by time. This means that a single frame can contain
  /// partition of the single series, but once a new series is started to be streamed it means that no more data will
  /// be sent for previous one.
  /// Series has to be sorted.
  rpc Series(SeriesRequest) returns (stream SeriesResponse);

  /// LabelNames returns all label names that is available.
  /// Currently unimplemented in all Thanos implementations, because Query API does not implement this either.
  rpc LabelNames(LabelNamesRequest) returns (LabelNamesResponse);

  /// LabelValues returns all label values for given label name.
  rpc LabelValues(LabelValuesRequest) returns (LabelValuesResponse);
}

/// WriteableStore represents API against instance that stores XOR encoded values with label set metadata (e.g Prometheus metrics).
service WriteableStore {
  // WriteRequest allows you to write metrics to this store via remote write
  rpc RemoteWrite(WriteRequest) returns (WriteResponse) {}
}

message WriteResponse {
}

message WriteRequest {
  repeated prometheus.TimeSeries timeseries = 1 [(gogoproto.nullable) = false];
  string tenant = 2;
  int64 replica = 3;
}

message InfoRequest {}

enum StoreType {
  UNKNOWN = 0;
  QUERY = 1;
  RULE = 2;
  SIDECAR = 3;
  STORE = 4;
  RECEIVE = 5;
}

message InfoResponse {
  // Deprecated. Use label_sets instead.
  repeated Label labels = 1 [(gogoproto.nullable) = false];
  int64 min_time = 2;
  int64 max_time = 3;
  StoreType storeType  = 4;
  // label_sets is an unsorted list of `LabelSet`s.
  repeated LabelSet label_sets = 5 [(gogoproto.nullable) = false];
}

message LabelSet {
  repeated Label labels = 1 [(gogoproto.nullable) = false];
}

/// PartialResponseStrategy controls partial response handling.
enum PartialResponseStrategy {
  /// WARN strategy tells server to treat any error that will related to single StoreAPI (e.g missing chunk series because of underlying
  /// storeAPI is temporarily not available) as warning which will not fail the whole query (still OK response).
  /// Server should produce those as a warnings field in response.
  WARN = 0;
  /// ABORT strategy tells server to treat any error that will related to single StoreAPI (e.g missing chunk series because of underlying
  /// storeAPI is temporarily not available) as the gRPC error that aborts the query.
  ///
  /// This is especially useful for any rule/alert evaluations on top of StoreAPI which usually does not tolerate partial
  /// errors.
  ABORT = 1;
}

message SeriesRequest {
  int64 min_time                 = 1;
  int64 max_time                 = 2;
  repeated LabelMatcher matchers = 3 [(gogoproto.nullable) = false];

  int64 max_resolution_window = 4;
  repeated Aggr aggregates    = 5;

  // Deprecated. Use partial_response_strategy instead.
  bool partial_response_disabled = 6;

  // TODO(bwplotka): Move Thanos components to use strategy instead. Including QueryAPI.
  PartialResponseStrategy partial_response_strategy = 7;

  // skip_chunks controls whether sending chunks or not in series responses.
  bool skip_chunks = 8;
}

enum Aggr {
  RAW     = 0;
  COUNT   = 1;
  SUM     = 2;
  MIN     = 3;
  MAX     = 4;
  COUNTER = 5;
}

message SeriesResponse {
  oneof result {
    Series series = 1;

    /// warning is considered an information piece in place of series for warning purposes.
    /// It is used to warn store API user about suspicious cases or partial response (if enabled).
    string warning = 2;
  }
}

message LabelNamesRequest {
  bool partial_response_disabled = 1;

  // TODO(bwplotka): Move Thanos components to use strategy instead. Including QueryAPI.
  PartialResponseStrategy partial_response_strategy = 2;
}

message LabelNamesResponse {
  repeated string names = 1;
  repeated string warnings = 2;
}

message LabelValuesRequest {
  string label = 1;

  bool partial_response_disabled = 2;

  // TODO(bwplotka): Move Thanos components to use strategy instead. Including QueryAPI.
  PartialResponseStrategy partial_response_strategy = 3;
}

message LabelValuesResponse {
  repeated string values = 1;
  repeated string warnings = 2;
}

/// Rules represents API that is responsible for gathering rules and their statuses.
service Rules {
  /// Rules has info for all rules.
  rpc Rules(RulesRequest) returns (stream RulesResponse);
}

/// RuleGroup has info for rules which are part of a group.
message RuleGroup {
  string name = 1;
  string file = 2;
  // In order to preserve rule ordering, while exposing type (alerting or recording)
  // specific properties, both alerting and recording rules are exposed in the
  // same array.
  repeated Rule rules = 3;
  double interval = 4;
  double evaluation_duration_seconds = 5; // Is it second?
  int64 last_evaluation_time = 6;
}

message Rule {
  oneof result {
    RecordingRule recording = 1;
    Alert alert= 2;
  }
}

enum AlertState {
  PENDING     = 0;
  FIRING      = 1;
  INACTIVE    = 2;
}

message AlertInstance {
  repeated Label labels = 1;
  repeated Label annotations = 2;
  AlertState state = 3;
  int64 active_at = 4;
  string value = 5;
}

message Alert {
  AlertState state = 1;
  string name = 2;
  string query = 3;
  double duration_seconds = 4; // Is it second?
  repeated Label labels = 5;
  repeated Label annotations = 6;
  repeated AlertInstance alerts = 7;
  string health = 8;
  string last_error = 9;
  double evaluation_duration_seconds = 10; // Is it second?
  int64 last_evaluation_time = 11;
}

message RecordingRule {
  string name = 1 [(gogoproto.jsontag) = "lol" ];
  string query = 2;
  repeated Label labels = 3;
  string health = 4;
  string last_error = 5;
  double evaluation_duration_seconds = 6; // Is it second?
  int64 last_evaluation_time = 7;
}

message RulesRequest {
  enum Type {
    ALL     = 0;
    ALERTING      = 1;
    RECORDING    = 2;
  }
  Type type = 1;
}

message RuleGroups {
  repeated RuleGroup groups = 1;
}

message RulesResponse {
  oneof result {
    // It is up to server implementation to decide how many of those to put here.
    RuleGroup group = 1;

    /// warning is considered an information piece in place of series for warning purposes.
    /// It is used to warn rule API users about suspicious cases or partial response (if enabled).
    string warning = 2;
  }
}
